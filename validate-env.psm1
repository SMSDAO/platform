#Requires -Version 7.0
<#
.SYNOPSIS
    SMSDAO Platform — Validate-Env Phase
.DESCRIPTION
    Checks environment safety without modifying production state.
    Creates .env.example if missing, verifies no secrets in source,
    ensures NEXT_PUBLIC_ vars are documented.
#>

using module ../utils/logger.psm1
using module ../utils/file-scan.psm1
using module ../reporting/pr-comment.psm1

function Invoke-ValidateEnvPhase {
    param(
        [Parameter(Mandatory=$true)]
        [object]$RepoProfile,

        [string]$Env          = "Dev",
        [hashtable]$CustomArgs = @{},
        [bool]$IsDryRun        = $false,
        [string]$PRNumber      = $env:PR_NUMBER,
        [string]$Token         = $env:GH_TOKEN,
        [string]$Repo          = $env:GITHUB_REPOSITORY
    )

    $phase   = "ValidateEnv"
    $start   = Get-Date
    $issues  = [System.Collections.Generic.List[string]]::new()
    $repairs = [System.Collections.Generic.List[string]]::new()

    Write-Step "Phase: $phase" -Phase $phase
    Invoke-PRComment -EventType "phase_start" -PhaseLabel $phase `
                     -Env $Env -Token $Token -Repo $Repo -PR $PRNumber -IsDryRun $IsDryRun

    try {
        # ── Rule 1: .env.example must exist ─────────────────────
        if (-not (Test-Path "./.env.example")) {
            $envLines = @(
                "# Auto-generated by SMSDAO platform — safe placeholders only.",
                "# Copy to .env and fill in real values. NEVER commit .env.",
                "NEXT_PUBLIC_ENV=development",
                "NEXT_PUBLIC_RPC_URL=https://placeholder-rpc.example.com",
                "NEXT_PUBLIC_API_URL=https://placeholder-api.example.com"
            )
            if (-not $IsDryRun) {
                $envLines | Set-Content "./.env.example" -Encoding UTF8
                $repairs.Add("Created .env.example with safe placeholders")
            } else {
                Write-Dry "Would create .env.example" -Phase $phase
            }
        }

        # ── Rule 2: .env must not be committed ───────────────────
        if (Test-Path "./.env") {
            if (Test-Path "./.gitignore") {
                $gi = Get-Content "./.gitignore" -Raw
                if ($gi -notmatch "(?m)^\.env$") {
                    $issues.Add(".env file exists but .gitignore does not exclude it — secret leak risk!")
                    if (-not $IsDryRun) {
                        Add-Content "./.gitignore" "`n.env`n.env.local`n.env.*.local"
                        $repairs.Add("Added .env to .gitignore")
                    }
                }
            } else {
                $issues.Add(".gitignore is missing — .env may be committed.")
            }
        }

        # ── Rule 3: Secret pattern scan in source ────────────────
        $criticalHits = Invoke-FilePatternScan `
            -Paths @("./src","./app","./pages","./components","./lib") `
            -Include @("*.ts","*.tsx","*.js","*.jsx") `
            -Patterns (Get-SecretPatterns | Where-Object { $_.severity -eq "critical" })

        foreach ($h in $criticalHits) {
            $issues.Add("Secret pattern '$($h.Category)' in $([System.IO.Path]::GetFileName($h.File)):$($h.LineNumber)")
        }

        # ── Rule 4: Next.js NEXT_PUBLIC_ coverage ────────────────
        if ($RepoProfile.Type -eq "nextjs" -and (Test-Path "./.env.example")) {
            $example   = Get-Content "./.env.example" -Raw
            $srcFiles  = Get-ChildItem "." -Include "*.ts","*.tsx","*.js","*.jsx" `
                             -Recurse -ErrorAction SilentlyContinue
            $referenced = [System.Collections.Generic.HashSet[string]]::new()
            foreach ($f in $srcFiles) {
                [regex]::Matches((Get-Content $f.FullName -Raw -ErrorAction SilentlyContinue),
                    'NEXT_PUBLIC_[A-Z_0-9]+') |
                ForEach-Object { [void]$referenced.Add($_.Value) }
            }
            foreach ($varName in $referenced) {
                if ($example -notmatch $varName) {
                    $issues.Add("$varName referenced in code but missing from .env.example")
                }
            }
        }

        # ── Surface ───────────────────────────────────────────────
        $repairs | ForEach-Object { Write-OK "Repaired: $_" -Phase $phase }
        $issues  | ForEach-Object { Write-Fail "Issue: $_" -Phase $phase }

        $eventType = if ($issues.Count -gt 0) { "phase_failure" } else { "env_validated" }
        $detail    = if ($issues.Count -gt 0) { $issues -join " | " } else { "All environment checks passed" }
        $duration  = (Get-Date) - $start

        Invoke-PRComment -EventType $eventType -PhaseLabel $phase `
                         -Env $Env -Token $Token -Repo $Repo -PR $PRNumber -IsDryRun $IsDryRun `
                         -Detail $detail `
                         -Metadata @{
                             issueCount  = $issues.Count
                             repairCount = $repairs.Count
                             duration    = "$([math]::Round($duration.TotalSeconds,1))s"
                         }

        if ($issues.Count -gt 0) {
            throw "Environment validation failed with $($issues.Count) issue(s)."
        }

        Write-OK "Environment validation passed." -Phase $phase
        return @{ status = "pass"; duration = $duration; repairs = $repairs.ToArray() }
    }
    catch {
        Invoke-PRComment -EventType "phase_failure" -PhaseLabel $phase `
                         -Env $Env -Token $Token -Repo $Repo -PR $PRNumber -IsDryRun $IsDryRun `
                         -Detail "$_"
        throw
    }
}

Export-ModuleMember -Function Invoke-ValidateEnvPhase
